# 2장. 리액트 핵심 요소 깊게 살펴보기

## JSX란?
JSX는 자바스크립트 표준코드가 아닌 페이스북이 임의로 만든 새로운 문법이다. 
그래서 JSX를 브라우저가 이해할 수 있도록 변환해주는 도구(트랜스파일러. 예를 들어 Babel)가 필요하다.

JSX는 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는데 많은 도움을 주는 새로운 문법이다.

JSX는 기본적으로 JSXElement, JsxAttributes, JSXChildren, JSXStrings 라는 네 가지 요소로 구성된다.
- JSXElement는 태그 이름, 속성, 자식 요소를 포함한다.
- JSXAttributes는 JSXElement의 속성을 나타낸다.
- JSXChildren는 태그의 자식 값을 나타낸다.
- JSXStrings는 태그의 문자열 값을 나타낸다.

JSX는 이러한 요소들을 조합하여 복잡한 트리 구조를 만들 수 있다.
JSX에서 자바스크립트로 변환한 결과를 보면 React.createElement() 함수를 호출하는 것을 볼 수 있다. JSXElement를 첫번째 인수로 전달하고, 옵셔널인 JSXChildren, JSXAttributes, JSXStrings를 이후 인수로 넘겨주어 처리한다.
JSXNamespaceName, JSXMemberExpression 을 리액트에서 사용하지 않지만 jSX를 사용하는 Preact, SolidJS, Nano JSX등 다양한 라이브러리에서는 해당 요소를 사용할 수 있으므로 이러한 스펙도 JSX 문법임을 알아둬야 한다.

## 가상 DOM과 리액트 파이버
### DOM이란?
DOM(Document Object Model)은 브라우저가 이해하는 문서 객체 모델이다. DOM은 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.
그리고 브라우저 렌더링 과정은 브라우저가 웹페이지를 렌더링하는 과정이다. 브라우저는 웹페이지를 렌더링하기 위해 먼저 HTML 파일을 파싱하여 DOM 트리를 생성한다. 그리고 CSS 파일을 파싱하여 CSSOM 트리를 생성한다. 마지막으로 DOM 트리와 CSSOM 트리를 결합하여 렌더링 트리를 생성한다. 이 때 css를 적용하는 과정에서 레이아웃(layout) - 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정, 페인트(paint) 과정이 발생한다.

### 가상 DOM의 탄생 배경
렌더링이 완료 된 이후에 사용자의 인터렉션으로 웹페이지가 변경되는 상황에서는 렌더링 트리를 다시 생성하여 렌더링 과정을 반복한다. 이 때 경우에 따라 특정 요소를 제외하고 대부분의 요소를 삭제하거나, 재 삽입, 위치를 재계산하는 등의 모든 변경 사항을 추적하는 것은 개발자 입장에서 너무 수고스러운 일이다. 이러한 문제점을 해결하기 위해 가상 DOM이 등장하게 되었다. 가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다. 이러한 방식이 무조건 일반적인 DOM을 관리하는 브라우저보다 무조건 빠르다고 오해하면 안되고, 애플리케이션을 개발하는데 합리적이다라고 보는 것이 옳다.

### 가상 DOM을 위한 아키텍처, 리액트 파이버
그렇다면 리액트는 여러 번의 렌더링 과정을 압축해 어떻게 최소한의 렌더링 단위를 만들어 내는 것일까? 이러한 가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 바로 리액트 파이버(React Fiber)이다.
파이버는 변경에 관련된 정보를 가지고 있고, 파이버를 기준으로 파이버 재조정자(Reconciler)가 화면에 렌더링을 요청하게 된다. 재조정(Reconciliation)은 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 알고리즘이다.

파이버는 어떻게 구현되어 있을까? 파이버는 하나의 작업 단위로 구성되어 있고, 리액트는 이 파이버를 하나씩 처리하고 finishedWork()라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다.
1. 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 이 단계에서 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
2. 커밋 단계에서 DOM에 변경 사항을 반영한다. commitWork()가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수 없다.

파이버는 단순한 자바스크립트 객체로 구성돼 있는 것을 볼 수 있는데, UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것이다. 이러한 UI 관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현하는 것이 리액트다.
그리고 UI 렌더링시 미처 다 그리지 못한 모습을 노출시키지 않기 위해 파이버 트리 두개로 더블 버퍼링 기법을 쓰는데, 현재 UI 렌더링을 위해 존재하는 current 트리를 기준으로 업데이트가 발생하면 새로 받은 데이터로 새로운 workInProgress 트리를 만들고 다음 렌더링에 이 workInProgress 트리가 최종적으로 렌더링 반영이 완료되면 current가 이 workInProgress로 변경된다.

그리고 최초 렌더링 시에는 모든 파이버를 새롭게 만들어야 했지만 이후에는 파이버가 이미 존재하므로 되도록 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다. 트리를 비교해서 업데이트하는 작업은 시도 때도 없이 일어나는데 이러한 반복적인 재조정 작업 때마다 새롭게 파이버 객체를 만드는 것은 리소스 낭비이므로 파이버 객체를 재사용하여 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트한다.

## 클래스형 컴포넌트
클래스 컴포넌트는 함수 컴포넌트와 다르게 라이프사이클 메서드를 가지고 있다. 라이프사이클 메서드는 컴포넌트가 생성되고 업데이트되고 사라지는 과정에서 호출되는 메서드들이다. 이 메서드들은 컴포넌트의 생명주기를 관리하는 역할을 한다.
그 중 getDerivedStateFromProps() 메서드는 클래스 컴포넌트에서 사용되는 메서드로, 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드다. componentDidCatch는 자식 컴포넌트에서 에러가 발생했을 때 실행되며 getDerivedStateFromProps에서 에러를 잡고 state를 결정한 이후에 실행된다. 일반적으로 앞의 두 메서드는 Error Boundary, 즉 에러 경계 컴포넌트를 만들기 위한 목적으로 사용된다.

클래스형 컴포넌트의 한계로는 
- 생명주기 메서드에서 state를 관리하는 것이 어렵다는 점이다. 서로 다른 여러 메서드에서 state의 업데이트가 일어날 수 있어서 state가 어떤 식의 흐름으로 변경돼서 렌더링이 일어나는지 디버깅하기 어렵다. 
- 클래스 컴포넌트 내부 로직의 재사용이 어렵고, 자바스크립트 환경에서는 클래스는 함수에 비해 상대적으로 어렵다. 
- 그리고 코드 크기를 최적화 하기 어렵다. 
    - 메소드의 이름이 minified 되지 않고, 사용하지 않는 메서드도 트리쉐이킹이 되지 않는다. 번들링을 최적화하기에 불리한 조건임. 
- 핫 리로딩이 어렵다. 핫리로딩은 코드에 변경 사항이 발생했을 때 앱을 다시 시작하지 않고서도 해당 변경된 코드만 업데이트해 변경 사항을 빠르게 적용하는 기법을 말한다. 클래스형 컴포넌트는 최초 렌더링 시에 instance를 생성하고, 그 내부에서 state 값을 관리하는데, 이 instance 내부에 있는 render를 수정하게 되면 instance를 새로 만들어야 반영할 수 있다. 새 instance에서 값은 당연히 초기화될 수 밖에 없다. 이에 반해 함수형 컴포넌트는 state를 함수가 아닌 클로저에서 저장해 두므로 함수가 다시 실행돼도 해당 state를 잃지 않고 다시 보여줄 수 있게 된다.

## 리액트의 렌더링이란?
리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떨게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다. 
그리고 리액트에서 렌더링이 발생하는 시나리오는 
1. 최초 렌더링
2. 리렌더링
    - 2-1. 클래스형 컴포넌트의 setState() 메서드 호출
    - 2-2. 클래스형 컴포넌트의 forceUpdate() 메서드 호출
    - 2-3. 함수형 컴포넌트의 useState()의 두 번째 배열 요소인 setter가 실행되는 경우
    - 2-4. 함수형 컴포넌트의 useReducer()의 dispatch 함수가 실행되는 경우
    - 2-5. 컴포넌트의 key props가 변경되는 경우 (key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다. 리렌더링이 발생하면 current 트리와 workInProgress 트리가 비교되고, 이 때 key 값이 변경되면 해당 요소는 삭제되고 새로 생성된다.)
    - 2-6. props가 변경되는 경우
    - 2-7. 컴포넌트의 부모 컴포넌트가 리렌더링되는 경우

### 리액트의 렌더링 프로세스
리액트의 렌더링은 렌더 단계와 커밋 단계라는 총 두 단계로 분리되어 실행된다. 

렌더 단계는 컴포넌트의 렌더링 결과를 계산하는 단계이고, 커밋 단계는 렌더링 결과를 실제 DOM에 반영하는 단계이다.
렌더 단계에서 비교하는 것은 크게 type, props, key이고, 이 세가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크 해 둔다.

그 다음으로 커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 준다. 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.
여기서 중요한 사실은 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다. 즉 변경사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있다.

## 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션
1. 메모이제이션도 어디까지나 비용이 드는 작업이므로 무분별하게 사용하지 않는 것이 좋다는 입장. 이전 결과를 캐시로 저장해 미래에 더 나은 성능을 위해 메오리를 차례대로 점유하게 된다. 렌더링도 비용이지만 메모리에 저장하는 것도 마찬가지로 비용이다. 메모이제이션으로 인한 성능 개선이 렌더링보다 낫지 않다면 결국 안하느니만 못하다. 한가지 더, 리액트가 useMemo를 언제까지고 성능 최적화를 위해 제공해 줄 것이라는 보장이 없다. 그러므로 미리 개발자가 렌더링이 많이 될 것 같은 부분을 예측해 메모이제이션하는, 섣부른 최적화는 옳지 못한 행동이다. 일단 애플리케이션을 어느 정도 만든 이후에 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인 하고 필요한 곳에서만 최적화하는 것이 옳다.
2. 리액트는 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해 둬야 한다. 그것이 기본적인 리액트의 재조정 알고리즘이기 때문이다. 즉, 어차피 리액트의 기본적인 알고리즘 때문에 이전 결과물은 어떻게든 저장해두고 있다. 따라서 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐인 것이다.
반면 memo를 하지 않았을 때 발생할 수 있는 문제는 다음과 같다.
- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 그리고 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

    useMemo와 useCallback도 마찬가지로 두가지 hook을 사용해 의존성 배열을 비교하고, 필요에 따라 값을 재계산하는 과정과 이러한 처리 없이 값과 함수를 매번 재생성하는 비용 중에서 무엇이 더 저렴한지 매번 계산해야 한다. 리렌더링이 발생할 때 메모이제이션을 하지 않았다면 모든 객체는 재생성되고, 결과적으로 참조는 달라지게 된다. 다른 컴포넌트의 props로 전달할 때 참조 투명성을 유지하기 위해서는 useCallback을 사용하는 것이 좋다. useMemo또한 마찬가지다. props로 넘어가거나 이를 활용할 여지가 있다면 사용하는 것이 좋다. 성능에 대해서 지속적으로 모니터링하고 관찰하는 것보다 섣부른 메모이제이션 최적화가 주는 이점이 더 클 수 있다.

아직 리액트를 배우고 있다면 섣부른 메모이제이션을 지양하는 자세로 실제 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보는 식으로 메모이제이션을 적용하는 것을 권장한다. 

현업에서 리액트를 사용하고 있거나 실제로 다룰 예정이지만 성능에 대해 깊게 연구해 볼 시간적 여유가 없는 상황이라면 일단 의심스로운 곳에는 먼저 다 적용해 볼 것을 권장한다.

