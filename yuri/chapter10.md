# 10장 리액트 17과 18의 변경 사항 살펴보기

## 리액트 17 버전 살펴보기

### 1. 리액트의 점진적인 업그레이드
- 새로운 주 버전이 릴리즈되면 이전 버전의 API 제공을 완전히 중단해 버리고, 전체 애플리케이션을 새롭게 업그레이드하기를 요구하고 있었다.
- 새로운 버전이 릴리즈되면 어떠한 API 수정이 있는지 일일이 확인해서 적용해야 하고, deprecated된 API는 또 어떻게 고쳐야 할지도 파악해야 한다.
- 이는 오래된 코드 베이스를 기반으로 돌아가는 웹 애플리케이션을 관리하는 개발자에게 번거로운 작업이기도 하다.

#### 리액트 17 버전부터는 점진적인 업그레이드가 가능하다.
- 전체 애플리케이션 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 점진적인 버전 업이 가능해진다.
- 물론 버전이 서로 다른 리액트가 혼합되어 있는 경우 당연히 한개의 버전일 때보다 당연히 관리 지점이 많아진다. 여전히 리액트 버전을 한꺼번에 업데이트하는 게 복잡성 감소 측면에서 좋다.
- 그러나 리액트 버전을 올리기에는 너무 부담이 되는 큰 애플리케이션의 경우에는 충분히 고려해 볼 만한 선택지가 될 수 있다.

### 2. 이벤트 위임 방식의 변경
- 리액트는 이벤트 위임 방식을 사용하며, 리액트 16버전까지는 모두 document에서 이벤트 위임을 수행하고 있었다.
- 그런데 리액트 17부터 이벤트 위임이 모두 document가 아닌 리액트 컴포넌트 최상단 트리, 즉 루트 요소에서 이벤트 위임을 수행하도록 변경되었다.

### 3. 더이상 필요 없는 import React from 'react'
- JSX는 브라우저가 이해할 수 있는 코드가 아니므로 JSX를 실행하기 위해 일반적인 자바스크립트로 변환하는 과정에서 import React from 'react' 구문이 필요했다.
- 리액트 17부터 바벨과 협력해 import 구문 없이도 JSX를 변환할 수 있게 됐다.
    - 17버전에서는 JSX를 변환할 때 필요한 모듈인 react/jsx-runtime을 자동으로 추가해주기 때문이다.
- 이는 번들링 크기를 줄이고 컴포넌트 작성을 더욱 간결하게 해준다.
- `npx react-codemod update-react-imports` 명령어를 사용해 import React from 'react' 구문을 제거할 수 있다.
- tsconfig.json의 jsx 옵션을 react-jsx로 변경해야 한다.

### 4. 이벤트 풀링 제거
- 이벤트 풀링이란 리액트에서 이벤트를 처리하기 위한 SyntheticEvent(합성 이벤트 - 브라우저의 기본 이벤트를 한번 더 감싼 이벤트 객체) 라는 이벤트 풀을 만들어서 이벤트가 발생할 때마다 가져오는 것을 의미한다. 
- 리액트는 이벤트가 발생할 때마다 이 SyntheticEvent 이벤트를 새로 만들고, 한번 이벤트 핸들러를 호출한 SyntheticEvent는 이후 재사용을 위해 null로 초기화된다.
- 비동기 코드로 이벤트 핸들러에 접근하기 위해서 별도 메모리 공간에 합성 이벤트 객체를 할당해야 한다는 점, 모던 브라우저에서는 이와 같은 방식이 성능 향상에 크게 도움이 안되기 때문에 이벤트 풀링 개념이 삭제됐다.

### 5. useEffect 클린업 함수의 비동기 실행
- 리액트 16 버전까지는 클린업 함수는 동기적으로 처리되었지만, 리액트 17 버전부터는 화면이 완전히 업데이트가 끝난 이후에 실행되도록 변경되었다.
- 리렌더링이 일어난 뒤에 클린업 함수가 실행되어 화면에 업데이트가 반영되는 시간인 commitTime이 조금이나마 빨라진 이점이 있다.

### 6. 컴포넌트의 undefined 반환에 대한 일관적인 처리
- 리액트 16, 17 버전까지는 컴포넌트가 undefined를 반환하면 오류가 발생하지만, 리액트 16에서 forwardRef, memo 에서 undefined를 반환하면 오류가 발생하지 않았다.
- 이는 코드 작성 시 혼란을 주는 요소였다.
- 리액트 17부터는 에러가 정상적으로 발생하도록 변경됐다.
- 리액트 18 버전부터는 컴포넌트가 undefined를 반환해도 에러가 발생하도록 일관적인 처리가 됐다.

## 리액트 18 버전 살펴보기
리액트 18 버전업의 핵심은 동시성(Concurrency)이다.  
동시성 렌더링: 렌더링을 긴급한 업데이트, 전환 업데이트(transition updates)로 나눠 긴급한 업데이트부터 진행함
전환 업데이트 중 긴급한 업데이트가 들어오면 전환 업데이트를 중단하고 긴급한 업데이트 우선 진행함
동시성 렌더링은 계산속도를 개선한 것이 아니라 우선순위를 지정하여 긴급한 업데이트를 우선 진행해 UI 차단을 최소화시킨 것

### 1. 새로운 훅
#### useId
- 리액트 18 버전부터는 useId 훅을 사용할 수 있다.
- 이 훅은 클라이언트와 서버 사이드 간에 동일한 값이 생성되어 하이드레이션 이슈 없이 컴포넌트 내부의 고유한 값을 생성한다.
- 같은 컴포넌트여도 서로 인스턴스가 다르면 다른 랜덤한 값을 만들어 내며, 모두 유니크한 값을 만들어 낸다.

#### useTransition
- useTransition 훅은 리액트 18의 변경 사항의 핵심 중 하나인 동시성(Concurrency) 을 다룰 수 있는 새로운 훅이다.
- 무거운 작업이 발생할 때, 이로 인해 렌더링이 가로막힐 여지가 있는 경우, UI 변경을 가로막지 않고 상태를 업데이트 할 수 있도록  하여 사용자 경험을 향상시키는 데 도움이 된다.
- 느린 렌더링 과정에서 로딩화면을 보여주거나, 혹은 지금 진행 중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업을 할 수 있게 된다.
```jsx
const [isPending, startTransition] = useTransition();

function handleClick() {
    // 긴급하지 않은 상태 업데이트를 하는 setter를 담는 함수를 인수로 받는다.
    startTransition(() => {
        setState(newState);
    });
}
```
##### startTransition을 사용할 때 주의점
1. `startTransition` 내부는 반드시 1개 이상의 상태를 업데이트하는 함수와, 관련된 작업만 넘길 수 있다.
2. `startTransition` 으로 넘겨주는 함수는 반드시 동기 함수여야 한다. `startTransition`이 작업을 지연시키는 작업과 비동기로 함수가 실행되는 작업 사이에 불일치가 일어나기 때문.
3. `startTransition`으로 넘겨주는 상태 업데이트는 전환 업데이트(transition updates)로 처리되어, 다른 모든 동기 상태 업데이트(긴급한 업데이트)로 인해 실행이 지연될 수 있다. 예를 들어 input과 input value에 따른 list가 있다고 가정했을 때, 타이핑으로 인해 setState가 일어나는 경우, 타이핑이 끝날 때까지 startTransition로 넘긴 list 상태 업데이트 실행이 지연될 수 있다.

#### useDeferredValue
- useDeferredValue는 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅이다.
- useTransition은 state값을 업데이트 하는 함수를 감싸서 사용하는 반면, useDeferredValue는 값 자체만을 감싸서 사용하는 것을 볼 수 있다.
```jsx
const [value, setValue] = useState(0);
const deferredValue = useDeferredValue(value);
```
- 만약 닞은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태를 업데이트힐 수 있는 코드에 접근할 수 있다면 -> `useTransition`
- 컴포넌트의 props와 같이 상태 없데이트에 관여할 수 없고, 오로지 값만 받아야 하는 경우 -> `useDeferredValue`를 사용한다.

#### useSyncExternalStore
- 리액트 18 버전부터는 렌더링을 일시 중지하거나 뒤로 미루는 등의 최적화가 가능해지면서, 렌더링을 일시 중지 과정에서 값이 업데이트되면 동일한 변수(데이터)에 대해서 서로 다른 컴포넌트 형태로 나타나는 테어링 현상이 발생할 가능성이 존재한다.
- 리액트에서 관리할 수 없는 외부 데이터 소스( 리액트 클로저 범위 밖에 있는, 글로벌 변수, document.body, window.innerWith, DOM, 외부 상태 관리 라이브러리 등)에 대해서 동시성 처리를 위한 훅이 `useSyncExternalStore`다.

```jsx
function subscribe(callback: (this: Window, event: UIEvent) => void ) {
    window.addEventListener('resize', callback);
    return () => window.removeEventListener('resize', callback);
}

function useWindowWidth() {
    // 1. 첫번째 인수는 외부 데이터 소스에 대한 구독 함수
    // 2. 두번째 인수는 컴포넌트에 필요한 현재 스토어의 데이터를 반환하는 함수
    // 3. (선택) 세번째 인수는 외부 데이터 소스에 대한 기본값을 반환하는 함수. 서버 사이드에서 렌더링되는 훅이라면 반드시 기본값을 반환해야 한다.
    return useSyncExternalStore(subscribe, () => window.innerWidth, () => 0);
    // window.innerWidth의 변경 여부를 확인해 리렌더링을 발생시킨다.
}

export default function App() {
    const windowWidth = useWindowWidth();
    return <div>{windowWidth}</div>;
}
```

#### useInsertionEffect
- useInsertionEffect는 CSS-in-JS 라이브러리를 사용할 때 주로 사용되는 훅이다.
- css의 추가 및 수정은 브라우저에서 렌더링하는 작업 대부분을 다시 계산해 작업해야 하는 매우 무거운 작업이므로, 이를 클라이언트 렌더링 시에 발생하지 않도록 리액트 17과 styled-components에서는 서버 사이드에서 스타일 코드를 삽입했다.
- 리액트 18 버전부터는 useInsertionEffect를 사용해 훅에서 이러한 작업을 도와줄 수 있다.
- useInsertionEffect는 모든 DOM의 변경 작업 이전에 동기적으로 실행된다. (useLayoutEffect는 모든 DOM의 변경 작업 이후에 실행된다.) 이는 브라우저가 다시금 스타일을 입혀서 DOM을 재계산하지 않아도 된다는 점에서 매우 차이가 크다.

### 2. react-dom/client
클라이언트에서 리액트 트리를 만들 때 사용되는 API가 변경됐다. 리액트 18 업그레이드시 반드시 확인해야 하는 내용이다.

#### createRoot
- 리액트 18 버전부터는 리액트의 루트 컴포넌트가 렌더링되고 있는 곳에서 createRoot와 render 함수를 함께 사용해야 한다.

#### hydrateRoot
- 서버 사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드다. 기존 hydrate 함수 대신 사용된다.

### 3. react-dom/server
#### renderToPipeableStream
- HTML을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업을 할 수 있는 메서드다.
- 기존 renderToNodeStream의 문제는 무조건 렌더링을 순서대로 해야 하고, 그 순서에 의존적이기 때문에 이전 렌더링이 완료되지 않는다면 이후 렌더링도 끝나지 않는다는 점이었다. (renderToNodeStream의 지원이 중단됐다)
- 이 메서드는 순서나 오래 걸리는 작업에 의존적이지 않도록 해준다.

#### renderToReadableStream
- renderToPipeableStream이 Node.js 환경에서의 렌더링을 위해 사용된다면, renderToReadableStream은 웹 스트림을 기반으로 모던 엣지 런타임 환경에서 작동된다.

### 4. 자동 배치(Automatic Batching)
- 자동 배치는 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미한다.
- 리액트 17버전에는 비동기 이벤트에서 자동 배치가 이뤄지고 있지 않았다. 동기와 비동기 배치 작업에 일관성이 없었다.
- 이를 보완하기 위해 리액트 18버전부터는 루트 컴포넌트를 createRoot를 사용해서 만들면 모든 업데이트가 자동 배치 작업으로 최적화할 수 있게 됐다.

### 5. 엄격모드(strict mode)
- 향후 리액트에서는 컴포넌트가 마운트 해제된 상태에서도 (컴포넌트가 렌더링 트리에 존재하지 않는 상태에서도) 컴포넌트 내부의 상태값을 유지할 수 있는 기능을 제공할 예정이라고 리액트 팀에서 밝혔다.
- 이러한 기능을 향후에 지원하기 위해 엄격모드(strict mode)의 개발 모드에 컴포넌트가 최초에 마운트될 때 자동으로 모든 컴포넌트를 마운트 해제하고 두번째 마운트에서 이전 상태를 복원하게 되는 새로운 기능을 도입했다.
- 즉 고의로 StrictMode에서 useEffect를 두 번 작동시키는 내용을 추가한 것이다.
- 따라서 useEffect를 사용할 때 반드시 적절한 cleanup 함수를 배치해서 반복 실행될 수 있는 useEffect로부터 최대한 자유로운 컴포넌트를 만드는 것이 좋다.

### 6. Suspense 가능 강화
- 아직 마운트되기 직전임에도 useEffect가 실행된는 문제가 수정됐다. 리액트 18버전에서는 실제로 컴포넌트가 화면에 노출될 때 useEffect가 실행된다.
- Suspense로 인해 컴포넌트가 보이거나 사라질 때도 effect가 정상적으로 실행된다.
- Suspense를 서버에서도 실행할 수 있게 된다.
- Suspense 내에 스로틀링이 추가됐다. 중첩된 Suspense의 fallback이 있다면 자동으로 스로틀되어 최대한 자연스럽게 보여주기 위해 최적화된 방식으로 렌더링된다.

















