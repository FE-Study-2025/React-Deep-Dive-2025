# 01. 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## ✅ 이벤트 루프와 비동기 통신의 이해

### 📌 1) 싱글 스레드 자바스크립트

자바스크립트는 싱글 스레드(single thread) 언어.

- 프로세스: 하나의 프로그램이 실행되는 작업 단위
- 스레드: 프로세스 안에서 실행되는 작은 작업 단위

자바스크립트가 <u>"싱글 스레드"</u>라는 말은 하나의 작업이 끝나야만 다음 작업을 수행한다는 뜻이다. (Run-to-completion)

#### 자바스크립는 왜 싱글 스레드로 설계되었을까?
- 멀티 스레드는 하나의 프로세스에서 동시에 서로 같은 자원에 접근할 수 있는데, 동시에 여러 작업을 수행하다 보면 같은 자원에 대해 여러 번 수정하는 등 동시성 문제가 발생할 수 있어 이에 대한 처리가 필요.
    - 예를 들어 자바스크립트가 멀티 스레딩을 지원해서 동시에 여러 스레드가 DOM을 조작할 수 있다면, 멀티 스레딩은 메모리 공유로 인해 동시에 같은 자원에 접근하면 타이밍 이슈가 발생할 수 있고, 이는 브라우저의 DOM 표시에 큰 문제를 발생시킬 수 있다.

### 📌 2) 이벤트 루프
그렇다면, 자바스크립트는 싱글 스레드인데 비동기 작업(예: setTimeout, fetch)은 어떻게 처리할까?

이 때 쓰이는 게 바로 **이벤트 루프(Event Loop)**

아래 내용은 ECMAScript 자바스크립트 표준에 나와있는 내용은 아니지만, 자바스크립트 런타임 환경에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치다.
- 이벤트 루프: 이벤트 루프의 역할은 호출 스택에 실행 중인 코드가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할을 한다.
    - 호출 스택: 실행할 코드를 순차적으로 저장해두는 스택이다.
    - 태스크 큐: 실행해야 할 태스크의 집합. 이벤트 루프는 태스크 큐에 있는 태스크를 실행 가능한 오래된 것부터 순차적으로 호출 스택에 넣는다.

### 📌 3) 자바스크립트 런타임 환경
자바스크립트 런타임 환경은 자바스크립트 코드가 실행되는 “실행 환경”을 의미한다. 단순히 자바스크립트 엔진(예: Chrome의 V8, Firefox의 SpiderMonkey)만 있는 것이 아니라, 코드 실행을 위해 필요한 여러 가지 구성 요소와 API들을 함께 포함하는 환경을 뜻한다.

### 주요 구성 요소
1. 자바스크립트 엔진
    - 자바스크립트 코드를 해석하고 실행하는 역할을 한다.
    - 엔진은 메모리 관리, 코드 컴파일 및 실행, 가비지 컬렉션 등의 기능을 수행한다.

2. 호스트 환경과 API
    - 자바스크립트 자체: 언어 사양에서는 순수한 문법과 기능만 정의하고 있으며, 파일 시스템 접근이나 네트워크 통신 같은 I/O 기능은 포함되어 있지 않다.

    - 호스트 환경: 자바스크립트 코드를 둘러싸고 있는 환경(예, 웹 브라우저, Node.js)이 추가적인 객체와 API를 제공한다.

        - 웹 브라우저의 경우: DOM(Document Object Model), BOM(Browser Object Model)과 같은 API를 통해 HTML, CSS와 상호작용하며, 타이머 함수(setTimeout, setInterval)나 이벤트 핸들링 등의 기능을 제공한다.

        - Node.js의 경우: 운영체제와의 상호작용을 위한 파일 시스템, 네트워크, 프로세스 관리 등의 API를 제공하며, 비동기 I/O를 libuv 라이브러리를 통해 효율적으로 관리한다.

3. 이벤트 루프와 콜 스택
    - 콜 스택(Call Stack): 자바스크립트 코드의 실행 순서를 관리하며, 동기적 실행 컨텍스트를 처리한다.
    - 이벤트 루프(Event Loop): 비동기 작업(예: 네트워크 요청, 타이머)이 완료되면, 이를 콜백 큐에 넣어 다시 실행될 수 있도록 순서를 조정한다.

이 구조 덕분에 자바스크립트는 단일 스레드 환경에서도 비동기 처리가 가능해진다.

### 호스트에 따른 차이점
- 웹 브라우저
    - 브라우저는 자바스크립트 엔진 외에도 HTML/CSS 렌더링, 사용자 인터페이스 관리 등 다양한 기능을 지원하는 API를 제공한다.
- Node.js
    - 브라우저와 달리 OS와 직접 상호작용할 수 있는 API(파일 시스템, 네트워크 등)를 제공하며, libuv 라이브러리를 사용해 이벤트 루프와 비동기 I/O를 처리한다.

#### 결론
자바스크립트 런타임 환경은 단순히 코드를 실행하는 엔진만 있는 것이 아니라, 그 코드가 주변 환경과 상호작용할 수 있도록 다양한 API와 시스템(메모리 관리, 이벤트 루프 등)을 제공하는 복합적인 실행 환경이다. 이를 통해 자바스크립트는 웹 브라우저나 서버 등 다양한 플랫폼에서 효과적으로 동작할 수 있다.

### 그렇다면 이 비동기 함수는 누가 수행할까?

- 비동기 작업들은 자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌 <u>태스크 큐가 할당되는 별도의 스레드</u>에서 수행된다.
- 그리고 <b>브라우저 또는 Node.js 같은 자바스크립트 런타임 환경</b>이 이 별도의 스레드에서 태스크 큐에 작업을 할당해 처리한다.
- 즉, 자바스크립트 코드 실행은 싱글 스레드에서 이루어지지만 이러한 외부 Web Api(setTimeout, fetch 등) 등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어간다.

#### <u>태스크 큐가 할당되는 별도의 스레드</u> 란?
브라우저는 자바스크립트 코드 실행과 별도로, 비동기 작업(예: 타이머, 네트워크 요청 등)을 처리하기 위해 내부적으로 여러 스레드를 사용한다. 다만, 이러한 스레드의 생성 및 관리는 브라우저의 내부 구현에 속하는 사항이라서, ECMAScript 표준에는 명시되어 있지 않고 각 브라우저마다 다르게 구현됩니다.

예를 들어,

네트워크 요청이나 타이머 같은 작업은 브라우저의 렌더링 엔진이나 네트워크 스택에서 OS의 스레드 라이브러리를 이용해 별도의 스레드(혹은 스레드 풀)에서 처리된다.

이때 해당 스레드들은 비동기 작업을 처리한 후 결과를 메인 스레드의 태스크 큐에 전달하여, 메인 스레드의 이벤트 루프가 이를 실행할 수 있도록 한다.

즉, 개발자가 직접 별도의 스레드를 생성하거나 제어하지 않으며, 브라우저가 내부적으로 최적화된 방식으로 필요한 시점에 스레드를 생성 및 관리한다. 이 과정은 브라우저마다 구현 세부사항이 달라 공개된 정보가 제한적이므로, 구체적인 스레드 생성 메커니즘은 일반적인 설명으로만 이해해야 한다.

### 📌 4) 태스크 큐와 마이크로 태스크 큐
- 태스크 큐: setTimeout, setInterval, setImmediate
- 마이크로 태스크 큐: Promise, process.nextTick, queueMicroTask, mutationObserver

- 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다. 
- 명세에 따르면, 마이크로 태스크 큐가 비어 있을 때까지 기존 태스크 큐의 실행은 뒤로 미루어진다.

##### 렌더링 시점
- 태스크 큐를 실행하기에 앞서 먼저 마이크로 태스트 큐를 실행하고, 이 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다. 
- 각 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다.

```html
<html>
    <body>
        <ul>
            <li>동기 코드: <button id="sync">0</button></li>
            <li>태스크: <button id="macrotask">0</button></li>
            <li>마이크로 태스크: <button id="microtask">0</button></li>
        </ul>
        <button id="macro_micro">모두 동시 실행</button>
        <script>
            const sync = document.getElementById('sync');
            const macrotask = document.getElementById('macrotask');
            const microtask = document.getElementById('microtask');
            const macro_micro = document.getElementById('macro_micro');

            sync.addEventListener('click', () => {
                for (let i = 0; i <= 100000; i++) {
                    sync.innerHTML = i;
                }
            });

            macrotask.addEventListener('click', () => {
                for (let i = 0; i <= 100000; i++) {
                    setTimeout(() => {
                        macrotask.innerHTML = i;
                    }, 0);
                }
            });

            microtask.addEventListener('click', () => {
                for (let i = 0; i <= 100000; i++) {
                    queueMicrotask(() => {
                        microtask.innerHTML = i;
                    });
                }
            });

            macro_micro.addEventListener('click', () => {
                for (let i = 0; i <= 100000; i++) {
                    sync.innerHTML = i;
                    setTimeout(() => {
                        macrotask.innerHTML = i;
                    }, 0);
                    queueMicrotask(() => {
                        microtask.innerHTML = i;
                    });
                }
            });
        </script>
    </body>
</html>
```
모든 것을 동시에 실행했을 경우 동기 코드와 마이크로 태스크 큐만 한번에 100000까지 올라가고, 태스크 큐만 순차적으로 렌더링 되는 것을 볼 수 있다.
```javascript
console.log('1');

setTimeout(() => {
    console.log('2');
}, 0);

Promise.resolve().then(() => {
    console.log('3');
});

// requestAnimationFrame은 브라우저에서 제공하는 API로, 
// 다음 리페인트(화면 갱신) 직전에 지정된 콜백 함수를 실행하도록 예약합니다. 
// 애니메이션 및 시각적 업데이트에 최적화된 API. 

/**
    requestAnimationFrame의 특징
    - 리페인트와 동기화:
    requestAnimationFrame은 브라우저의 렌더링 주기와 맞춰 콜백을 실행합니다. 이로 인해 화면에 변경 사항이 있을 때 최적의 타이밍에 업데이트가 이루어져, 불필요한 계산이나 렌더링 없이 애니메이션을 보다 부드럽게 구현할 수 있습니다.

    - 배터리 및 자원 최적화:
    페이지가 백그라운드에 있을 때(예: 탭이 비활성화된 경우) 브라우저는 requestAnimationFrame의 실행을 일시 중지합니다. 이를 통해 불필요한 CPU 및 배터리 소모를 줄입니다.

    - 정확한 프레임 타이밍:
    requestAnimationFrame은 브라우저가 다음 리페인트를 준비하는 시점에 실행되므로, 프레임 간 간격이 브라우저의 디스플레이 주사율에 최적화되어 있습니다. 디스플레이의 프레임 레이트(예: 60fps)에 맞춰 호출되므로, 애니메이션이 더 부드럽게 표현됩니다.
**/
window.requestAnimationFrame(() => {
    console.log('4');
});
/** 
 requestAnimationFrame의 콜백은 일반적인 태스크 큐(예: setTimeout, setInterval 등)에 등록되는 작업과는 다르게, 브라우저의 렌더링 파이프라인 내에서 별도로 관리되는 내부 큐에 저장된다. 즉, requestAnimationFrame은 태스크 큐에 해당하지 않는다.

브라우저는 requestAnimationFrame 콜백들을 별도의 큐에 모아두고, 현재 사이클의 모든 동기 코드와 마이크로 태스크가 완료된 후, 그리고 다음 리페인트 직전에 이 내부 큐의 콜백들을 실행한다.
**/

```

1. 동기 코드 실행

- console.log('1'):
    - 스크립트 실행 시 가장 먼저 실행되며, 콘솔에 1을 출력한다.

- setTimeout(..., 0):
    - 0밀리초 후에 실행하도록 요청하지만, 이는 macrotask(태스크 큐)에 등록된다.

- Promise.resolve().then(...):
    - 즉시 해결되는 Promise이므로, 그 후속 콜백(then)은 microtask(마이크로 태스크 큐)에 등록된다.

- window.requestAnimationFrame(...):
    - 다음 리페인트(브라우저가 화면을 다시 그리기 전)에 실행될 콜백을 예약한다.

2. 동기 코드 종료 후 마이크로 태스크 처리
- 동기 코드가 모두 실행된 후, 이벤트 루프는 먼저 마이크로 태스크 큐를 비운다.
- 이때 Promise의 then 콜백이 실행되어 콘솔에 3을 출력한다.

3. 리페인트와 requestAnimationFrame 처리
- 마이크로 태스크 처리가 완료되면, 브라우저는 리페인트 사이클로 진입한다.
- 리페인트 직전에, 예약된 requestAnimationFrame 콜백이 실행되어 콘솔에 4를 출력한다.

4. 태스크 큐(macrotask) 처리
- 리페인트가 완료된 후, 이벤트 루프는 다음 macrotask(태스크 큐)로 넘어갑니다.
- 그때 setTimeout 콜백이 실행되어 콘솔에 2를 출력한다.

최종 실행 순서:
1 → 3 → 4 → 2

이 과정은 자바스크립트 이벤트 루프의 기본 원칙에 따른 것으로, 동기 코드 → 마이크로 태스크 큐 → 리페인트(requestAnimationFrame) → macrotask 큐 순서로 실행된다.

