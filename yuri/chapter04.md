# 4장. 서버 사이드 렌더링

## 서버 사이드 렌더링이란?

싱글 페이지 애플리케이션이 자바스크립트를 활용해 하나의 페이지에서만 렌더링 수행하는 것과 대조적으로, 서버 사이드 렌더링은 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링을 수행하고 클라이언트에게 렌더링된 결과를 전달하는 방식이다.

- 왜 최근에 서버 사이드 렌더링이 주목받는가?

    웹페이지가 점점 느려지는 상황에 대한 문제점을 싱글 페이지 애플리케이션의 대생적인 한계에서 찾고, 이를 개선하고자 서버에서 페이지를 렌더링해 제공하는 기존 방식의 웹 개발이 다시금 떠오르고 있다.

### 서버 사이드 렌더링의 장단점
#### 장점
- 최초 페이지 진입이 비교적 빠르다.
  - 렌더링이 HTTP 요청에 의존적이거나 렌더링해야 할 HTML의 크기가 커진다면 상대적으로 서버 사이드 렌더링이 더 빠를 수 있다.
- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.
  - 검색 엔진 로봇이 페이지에 진입해서 HTML을 다운로드할 때 자바스크립트 코드는 실행하지 않는다.
  - 따라서 검색 엔진에 제공할 정보를 서버에서 가공해서 페이지 최초 진입시 HTML 응답으로 제공할 수 있으므로 검색 엔진 최적화가 쉽다.
- 누적 레이아웃 이동이 적다.
  - 누적 레이아웃 이동이란 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험을 말한다.
  - 싱글 페이지 애플리케이션에서는 페이지 콘텐츠가 api 요청에 의존하며, 각기 다른 응답에 대한 처리를 제대로 하지 않는다면 누적 레이아웃 이동 문제가 발생할 수 있으나, 서버 사이드 렌더링의 경우 api 요청이 완전히 완료된 이후에 완성된 페이지를 제공하므로 이러한 문제에서 비교적 자유롭다.
    - 그러나 useEffect에서 실행되는 시점에서 렌더링의 변화 또한 서버 사이드 애플리케이션, 싱글 페이지 애플리케이션 모두 문제가 될 수 있다.
    - 모든 api 요청이 완료되기 전까지 서버 사이드 렌더링에서 페이지가 렌더링되지 않을 것이므로 최초 페이지 다운로드가 굉장히 느려질 수도 있다.
- 사용자의 디바이스 성능에 비교적 자유롭다
  - 자바스크립트 리소스 실행은 사용자의 디바이스에서만 실행되므로 절대적으로 사용자 디바이스 성능에 의존적이다.
  - 그러나 서버사이드 렌더링을 수행하면 이러한 부담을 서버에 나눌 수 있으므로 사용자의 디바이스 성능으로부터 조금 더 자유로워질 수 있다.
  - 물론 사용자 방문이 폭증에 서버에 부담이 가중되거나 이를 위한 적절한 처리가 수반돼 있지 않다면 서버사이드 렌더링도 충분히 느려질 수 있다.
- 보안에 좀 더 안전하다
  - 인증 혹은 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 보안 문제를 줄일 수 있다.

#### 단점
- 소스코드를 작성할 때 항상 소스코드 전반에 걸쳐 서버 환경을 고려해야 한다.
  - 만약 서버에서 실행될 가능성이 있는 코드라면 브라우저 전역 객체인 window, sessionStorage 와 같은 전역 객체들에 대한 접근을 최소화하고, 사용이 불가피 하다면 해당 코드가 서버 사이드에서 실행되지 않도록 처리해야 한다. (외부에서 의존하고 있는 라이브러리도 마찬가지)
- 적절한 서버가 구축돼 있어야 한다.
  - 서버 사이드 렌더링은 말 그대로 사용자의 요청을 받아 렌더링을 수행할 서버가 필요하다. 사용자의 요청에 따라 적절하게 대응할 수 있는 물리적인 가용량을 확보해야 하고, 때로는 예기치 않은 장애 상황에 대응할 수 있도록 복구 전략을 수립해야 한다. 또한 요청을 분산시키고 프로세스가 예기치 못하게 다운될 때를 대비해 PM2(NodeJS 프로세서를 관리하는 원활한 서버 운영을 위한 패키지) 같은 프로세스 매니저의 도움도 필요하다.
- 서버 사이드 렌더링에서 최초 렌더링에 지연이 발생할 때 문제
  - 애플리케이션의 규모가 커지고 작업이 복잡해지면서 서버에서 다양한 요청의 병목 현상이 심해진다면 사용자에게 보여줄 페이지에 대한 렌더링 작업이 끝나기까지 시간이 느려져 더 안좋은 사용자 경험을 제공할 수도 있다.

### SPA와 SSR을 모두 알아야 하는 이유
모든 무거운 작업을 서버에서 이뤄진다고 해서 모든 성능 문제가 해결되지는 않는다. 웹페이지의 설계와 목적, 그리고 우선순위에 따라 싱글 페이지 애플리케이션이 더 효율적일 수도 있다. 따라서 서버 사이드 렌더링과 싱글 페이지 애플리케이션의 장단점을 모두 이해하고 필요에 따라 맞는 방법을 사용할 수 있도록 하는 것이 중요하다.


## 서버 사이드 렌더링을 위한 리액트 API 살펴보기
- renderToString
  
  서버 사이드 렌더링을 구현하는 데 가장 기초적인 API이며 인수로 주어진 리액트 컴포넌트를 기준으로 빠르게 브라우저가 렌더링할 수 있는 HTML을 제공하는 함수이다.

  ```jsx
  const result = ReactDOMServer.renderToString(React.createElement('div', {id: 'root'}, <SampleComponent />));
  ```
  반환된 HTML에 data-reactroot 속성은 리액트 컴포넌트의 루트 엘리먼트가 무엇인지 식별하는 역할을 한다. 이 속성은 이후에 자바스크립트를 실행하기 위한 hydrate 함수에서 루트를 식별하는 기준점이 된다.
  ```html
  <div id="root" data-reactroot="">
    <h1>Hello, World!</h1>
  </div>
  ```
  
- renderToStaticMarkup

  renderToString 과 매우 유사하나, 앞서 루트 요소에 추가한 data-reactroot 속성을 추가하지 않는다. 즉, 리액트의 이벤트 리스너가 필요 없는 완전히 순수한 HTML을 제공한다.

- renderToNodeStream

  renderToNodeStream의 결과물은 utf-8로 인코딩된 바이트 스트림인 ReadableStream 이다. 스트림은 큰 데이터를 다룰 때 데이터를 청크(chunk, 작은 단위)로 분리해 순차적으로 처리할 수 있다는 장점이 있다. 대부분의 널리 알려진 리액트 서버 사이드 렌더링 프레임워크는 모두 renderToString 대신 renderToNodeStream을 사용한다.

- renderToStaticNodeStream

  renderToStaticNodeStream은 renderToNodeStream과 제공하는 결과물은 동일하나, renderToStaticMarkup과 마찬가지로, 리액트 자바스크립트에 필요한 리액트 속성이 제공되지 않는다.

- hydrate
  
  renderToString과 renderToNodeStream으로 생성된 HTML에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.
  
  ```jsx
  const rootElement = document.getElementById('root');

  ReactDOM.render(<App />, rootElement);

  // containerId를 가리키는 element는 서버에서 렌더링된 HTML의 특정 위치를 의미한다.
  const element = document.getElementById('root');
  // 해당 element를 기준으로 리액트 이벤트 핸들러를 붙인다.
  ReactDOM.hydrate(<App />, element);
  ```
  render 함수와의 차이점은 hydrate는 기본적으로 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행되고, 이 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업만 실행한다. 따라서 hydrate로 넘겨준 두 번째 인수에는 이미 렌더링된 정적 HTML 정보가 반드시 담겨 있어야 한다.

  render 함수는 인수로 받은 HTML요소에 해당 컴포넌트(App)를 렌더링하며, 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업을 포함한다.
  
  또한 hydrate는 렌더링을 수행한 결과물 HTML과 인수로 넘겨받은 HTML을 비교하는 작업을 수행한다. 여기서 불일치가 발생하면 hydrate가 렌더링한 기준으로 웹페이지를 그리게 된다.

  
## Next.js 톺아보기

- `pages/_app.tsx`
  
  _app.tsx, 그리고 내부에 있는 default export로 내보낸 함수는 애플리케이션의 전체 페이지의 시작점이다. 
  최초에는 서버 사이드 렌더링을 수행하며, 이후에는 클라이언트 사이드 렌더링을 수행한다.

  _app.tsx에서 할 수 있는 내용으로는
  - 에러 바운더리를 사용해 애플리케이션 전역 에러 처리
  - reset.css 같은 전역 css 선언
  - 모든 페이지에 공통으로 사용 또는 제공해야 하는 데이터 제공

- `pages/_document.tsx`
  
  애플리케이션의 HTML을 초기화하는 곳이다.
  `<html>`이나 `<body>` 에 DOM 속성을 추가하는 작업을 수행할 수 있다.

  _app.tsx와 차이점
  - _document.tsx는 서버 사이드 렌더링 시에만 실행된다. 따라서 이 파일에서 이벤트 핸들러를 추가하는 작업은 수행할 수 없다.
  - next/document에서 제공하는 head는 오직 _document.tsx에서만 사용할 수 있다. 또한 next/document `<Head />` 내부에서는 `<title>` 태그를 사용할 수 없다. 만약 웹 애플리케이션에 공통 제목이 필요하면 _app.tsx에서, 페이지별 제목이 필요하다면 페이지 파일 내부에서 next/head 가 제공하는 `<Head />` 컴포넌트를 사용해야 한다.
  - getServerSideProps, getStaticProps 함수 사용이 불가하다.
  - 요약하면 _app.tsx는 Next.js를 초기화 하는 파일로, Next.js 설정과 관련된 코드를 모아주는 곳이며, 경우에 따라 서버, 클라이언트 모두에서 렌더링될 수 있다.
  - _document.tsx는 웹 애플리케이션의 뼈대가 되는 HTML 설정과 관련된 코드를 추가하는 곳이며 반드시 서버에서만 렌더링된다.

- `pages/index.tsx`

  개발자가 원하는 페이지를 구현하는 파일이다. 라우팅이 파일명으로 이어지는 구조를 가지고 있다.
  
  - `pages/index.tsx` 파일은 루트 페이지를 의미한다.
  - `pages/hello.ts` 파일명이 주소가 되며 디렉터리의 깊이만틈 주소를 설정할 수 있다.
  - `pages/hello/word.tsx` 과 `pages/hello/word/index.tsx` 는 같은 주소를 가리킨다.
  - `pages/hello/word/[greeting].tsx` 에서 []의 의미는 동적 라우트를 가리킨다.
  - `pages/hello/word/[...props].tsx` 에서 [...props] 는 전개 연산자와 작동이 동일하며 pages/hello/word/ 하위 모든 주소가 여기로 온다. [...props] 값은 props라는 변수에 배열로 오게 된다.

  #### 서버 라우팅과 클라이언트 라우팅 차이
  a 태그를 사용하는 경우 페이지의 모든 리소스를 처음부터 다 가져온다. 즉 서버에서 렌더링을 수행하고 클라이언트에서 hydrate하는 과정을 거친다.
next/link 와 next/router 는 Next.js에서 라우팅을 위한 두 가지 방법이며 클라이언트에서 필요한 자바스크립트만 불러온 뒤 라우팅하는 클라이언트 라우팅/렌더링 방식이다. 그래서 해당 페이지 이동에 필요한 내용만 받아 마치 싱글 페이지 애플리케이션 처럼 페이지 전환이 이루어진다.

이동할 페이지에 getServerSideProps와 같은 서버 관련 로직이 있더라도 전체 페이지를 가져오는 것이 아닌, 해당 페이지의 getServerSideProps 결과를 json 파일만을 요청해서 가져오는 것을 알 수 있다.

애플리케이션을 처음부터 서버에서 다시 불러와야 하는 드문 케이스 외에는 Next.js가 제공하는 라우터를 사용해 페이지를 이동하는 것이 좋다.


- `pages/api/hello.ts`

  다른 pages 파일과 다르게 HTML 요청을 하는 게 아니라 단순히 서버 요청을 주고받게 된다.
  서버에서 내려주는 데이터를 조합해 BFF(Backend For Frontend) 형태로 활용하거나, 완전한 풀스택 애플리케이션을 구축하고 싶을 때, 혹은 CORS(Cross-Origin Resource Sharing) 문제를 해결하고 싶을 때 사용한다.

### Data Fetching
- getStaticProps, getStaticPaths

  블로그나 게시판과 같이 사용자와 관계없이 정적으로 결정된 페이지를 보여주고자 할 때 사용된다. 이 두 함수를 사용하면 빌드 시점에 미리 데이터를 불러온 다음에 정적인 HTML 페이지를 만들 수 있다.

- getServerSideProps

  서버에서 실행되는 함수이며 해당 함수가 있다면 무조건 페이지 진입 전에 이 함수를 실행한다.
  getServerSideProps의 반환 값을 기반으로 아래와 같은 HTML을 렌더링한다.

  ```html
  <!DOCTYPE html>
  <html>
    <body>
        <div id="root" data-reactroot="">
            <h1>Hello, World!</h1>
            <p>This is a sample post.</p>
        </div>
        <script id="__NEXT_DATA__" type="application/json">
            {
                "props": {
                    "pageProps": {
                        "post": {
                            "title": "Hello, World!",
                            "content": "This is a sample post."
                        }
                    },
                    "__N_SSP": true,
                    "page": "/hello/[id]",
                    "query": {
                        "id": "1"
                    },
                    "buildId": "1234567890",
                    "isFallback": false,
                    "gssp": true,
                    "scriptLoader": []
                }
            }
        </script>
    </body>
  </html>
  ```
  리액트의 서버 사이드 렌더링 동작을 보면
  1. 서버에서 fetch 등으로 렌더링에 필요한 정보를 가져오고
  2. 1번에서 가져온 정보를 기반으로 HTML을 완성한다.
  3. 2번에서 완성된 HTML을 클라이언트(브라우저)에게 전달한다.
  4. 3번의 정보를 바탕으로 클라이언트에서 hydrate 작업을 한다.
  5. 이 과정에서 hydrate로 만든 리액트 컴포넌트 트리와 서버에서 만든 HTML이 다르다면 불일치 에러를 밷는다.
  6. 5번 작업도 1번과 마찬가지로 fetch 등을 이용해 정보를 가져와야 한다.

  즉, 1번과 6번 작업 사이에 fetch 시점에 따라 결과물의 불일치가 발생할 수 있으므로 1번에서 가져온 정보를 결과물인 HTML에 script 형태로 내려주는 것이다. 6번에서 1번 작업처럼 재요청하는 대신, `<script>` 태그를 통해 1번의 데이터를 동일하게 가져올 수 있다.

  __NEXT_DATA__ 스크립트 태그는 페이지 렌더링에 필요한 데이터를 담고 있으며, 해당 데이터는 `window.__NEXT_DATA__` 객체에 저장된다. 
  그리고 getServerSideProps의 props는 props의 결과를 HTML에 정적으로 작성해서 내려주기 때문에 반드시 `JSON.stringify`로 직렬화할 수 있는 값만 제공해야 한다.

  또한 이 함수는 사용자가 매 페이지를 호출할 때마다 실행되고, 이 실행이 끝나기 전까지는 사용자에게 어떠한 HTML도 전달하지 않기 때문에 최대한 간결하게 작성해야 한다. 꼭 최초에 보여줘야 하는 데이터가 아니라면 클라이언트에서 호출하는 것이 더 유리하다.

- getInitialProps

  라우팅에 따라서 서버와 클라이언트 모두에서 실행 가능하기 때문에 해당 메서드에 코드를 작성할 때 주의를 기울여야 한다. _app.tsx나 _error.tsx 와 같이 Next.js의 특성상 사용이 제한돼 있는 페이지에서만 사용하는 것이 좋다.

  웹서비스를 최초에 접근했을 때만 실행하고 싶은 내용은 _app.tsx 파일내에 getInitialProps 내부에 담아 둘 수 있다.
  - userAgent 확인
  - 사용자 정보와 같은 애플리케이션 전역에서 걸쳐 사용해야 하는 정보 등을 호출하는 작업
  

  