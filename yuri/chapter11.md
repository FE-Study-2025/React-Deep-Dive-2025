# 11장 Next.js 13과 리액트 18

### 1. app 디렉터리의 등장
Next.js 12버전까지는 페이지 공통 레이아웃을 유지할 수 있는 방법은 _app.tsx 파일이 유일했다. 이러한 레이아웃의 한계를 극복하기 위해 나온 것이 Next.js의 app 레이아웃이다.

#### 1-1. 라우팅
- 라우팅을 정의하는 법: Next.js 13의 app/a/b 는 a/b로 변환되며, 파일명은 무시된다. 폴더명까지만 주소로 변환된다. app 디렉터리 내부의 파일명은 라우팅 명칭에 아무런 영향을 미치지 못한다.

#### 1-2. layout.js
- app 디렉터리 내부의 폴더에 포함될 수 있는 파일 중 하나며, 해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모두 영향을 미친다.
- 루트에는 단 하나의 layout을 만들어 둘 수 있고, 이 layout은 모든 페이지에 영향을 미치는 공통 레이아웃이다.
- _document.jsx 에서만 처리할 수 있었던 CSS-in-JS 초기화나, html, body 태그에 대한 스타일 처리 같은 추가 작업을 이전 Next.js에서 제공하는 태그를 사용하지 않고 처리할 수 있다.

##### layout에서 주의해야 할 점
1. app 디렉터리 내부에서 무조건 `layout.{js|jsx|ts|tsx}`로 사용해야 한다.
2. layout은 children을 props로 받아서 렌더링해야 한다.
3. layout 내부에는 반드시 export default로 내보내는 컴포넌트가 있어야 한다.

#### 1-3. page.js
- page도 역시 app 디렉터리 내부의 예약어다. 무조건 `page.{js|jsx|ts|tsx}`로 사용해야 한다.
- page도 역시 내부에서 반드시 `export default`로 내보내는 컴포넌트가 있어야 한다.
- page가 받는 props는 다음과 같다.
  - params: 옵셔널한 값으로, `[...id]`와 같은 동적 라우트 파라미터를 사용할 경우 해당 파라미터에 값이 들어온다.
  - searchParams: 옵셔널한 값으로, 주소에 있는 쿼리 스트링을 객체로 받아온다.
    - 이 값은 layout에서는 제공되지 않는다. 이유는 layout은 페이지 탐색 중에는 리렌더링을 수행하지 않기 때문이다. 즉 같은 페이지에서 `search parameter`만 다르게 라우팅을 시도하는 경우 layout을 리렌더링하는 것은 불필요하기 때문이다. 그래서 `search parameter`에 의존적인 작업을 해야 한다면 반드시 page 내부에서 수행해야 한다.

#### 1-4. error.js
- 공통 에러 컴포넌트이고, 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능해진다.
- error 페이지는 `error: Error` 객체와 에러 바운더리를 초기화할 `reset: () => void` 를 props로 받는다.
- 에러 바운더리는 클라이언트에서만 작동하므로 error 컴포넌트는 클라이언트 컴포넌트여야 한다.
- 같은 depth의 layout에서 에러가 발생하는 경우 해당 error 컴포넌트로 이동하지 않는다. layout에서 발생한 에러를 처리하고 싶다면 상위 컴포넌트의 error 컴포넌트 또는 루트 에러 처리를 담당하는 `app/global-error.js` 파일을 만들어야 한다.

#### 1-5. not-found.js
- 404 페이지를 처리하는 파일이고, 서버 컴포넌트로 구성되어야 한다.

#### 1-6. loading.js
- 리액트 `Suspense`를 기반으로 해당 컴포넌트가 렌더링되는 동안 로딩 상태를 표시할 수 있게 해준다.

#### 1-7. route.js
- `/app/api`를 기준으로 디렉터리 라우팅을 지원하며, app 라우팅에서 파일명에 대한 라우팅을 지원하지 않는 것 처럼 `/api` 에 대해서도 파일명 라우팅이 없어지고, 디렉터리 라우팅만 지원한다. 그리고 파일명은 `route.js`로 통일됐다.
- route.ts 파일 내부에 REST API의 get, post와 같은 메서드명을 선언해 두면 HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동한다.
- route.ts가 존재하는 폴더 내부에는 `page.{js|jsx|ts|tsx}`가 존재할 수 없다.
- route의 함수들은 request, context 등의 파라미터를 받을 수 있다.
  - `request`: NextRequest 객체이며, API 요청과 관련된 cookie, headers 뿐만 아니라 nextUrl 같은 주소 객체도 확인할 수 있다.
  - `context`: params만을 가지고 있는 객체이고, 동적 라우팅 파라미터 객체가 포함돼 있다.


### 2. 리액트 서버 컴포넌트
리액트 18에서 새로 도입된 리액트 서버 컴포넌트는 서버 사이드 렌더링과 완전히 다른 개념이다. 리액트는 클라이언트 중심으로 돌아가기 때문에 발생하는 한계를 해결하기 위해 서버 컴포넌트가 도입되었다.

#### 2-1. 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

#### **1. 타사 라이브러리의 클라이언트 부담**
- 특정 라이브러리를 import하면 **클라이언트에서 다운로드 + 실행** 필요 → 사용자 기기에 부담 증가.  
- **해결책**: 서버에서 라이브러리를 실행하고, **결과물만 클라이언트에 전달**하면 성능 향상 가능.

#### **2. 백엔드 데이터 접근의 비효율성**
- 리액트에서는 **REST API 등을 사용해 백엔드 데이터에 접근**하는 것이 일반적.  
- **해결책**: 데이터베이스, 파일 시스템에 **직접 접근 가능**하면 API 호출 단계가 줄어들어 효율 증가.

#### **3. 자동 코드 분할(코드 스플리팅) 불가능**
- 리액트는 기본적으로 **자동 코드 분할을 지원하지 않음**. `lazy`를 사용해 수동으로 분할해야 하지만, **누락 가능성 존재**.
- 특정 조건문에서 지연 로딩된 컴포넌트를 호출하려면, **먼저 어떤 컴포넌트를 불러올지 결정 불가** → 성능 이점 상쇄.
- 해결 방법:
  - **서버에서 자동 코드 분할을 수행**하면, 개발자가 직접 코드 분할을 신경 쓰지 않아도 **성능 최적화 가능**.

#### **4. 클라이언트-서버 연쇄 요청 대응 어려움**
- 부모 컴포넌트의 요청이 완료되기 전까지, **자식 컴포넌트의 서버 요청이 지연**됨.  
- 이 과정에서 **불필요한 렌더링 발생** → 성능 저하.  
- **해결책**: 서버에서 요청을 처리하면 **클라이언트-서버 요청 지연 최소화** 가능.

#### **5. 클라이언트의 높은 추상화 비용**
- 클라이언트에서 **복잡한 연산이 필요하면 성능 저하** 발생.  
- **해결책**: 서버에서 복잡한 계산을 수행하고, 클라이언트에는 **가벼운 결과물만 전송** → 속도 개선 & 부담 감소.

**결론**: 서버에서 더 많은 작업을 처리하면, 클라이언트의 부담을 줄이고 성능을 최적화할 수 있음.

#### 2-2. 서버 컴포넌트란?
- 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법을 의미함.
- 서버에서 할 수 있는 일은 서버가 처리하게 두고, 서버가 할 수 없는 나머지 작업은 클라이언트인 브라우저에서 수행된다.
- 서버 사이드 렌더링과 클라이언트 사이드 렌더링 구조의 장점을 모두 취하고자 하는 것이 서버 컴포넌트의 목표이다.
- 리액트는 모든 컴포넌트를 다 서버에서 실행 가능한 것으로 분류하나, 파일의 맨 첫 줄에 `'use client'`라고 작성하면 클라이언트 컴포넌트라는 것을 명시할 수 있다.

#### 2-3. 서버 사이드 렌더링과 서버 컴포넌트의 차이
- 서버 사이드 렌더링의 목적은 정적인 HTML을 빠르게 내려주는 데 초점을 두고 있다. 따라서 여전히 초기 HTML이 로딩된 이후에는 클라이언트에서 자바스크립트 코드를 다운로드하고, 파싱하고, 실행하는 데 비용이 든다.
- 서버 컴포넌트를 활용해 서버에서 렌더링 할 수 있는 컴포넌트를 서버에서 완성해서 제공받은 다음, 클라이언트 컴포넌트는 서버 사이드 렌더링으로 초기 HTML을 빠르게 전달받을 수 있다. 그래서 서버 사이드 렌더링과 서버 컴포넌트는 상호보완하는 개념으로 봐야 한다.

#### 2-4. 서버 컴포넌트는 어떻게 작동하는가?
1. 서버가 렌더링 요청을 받으면 리액트 서버 컴포넌트를 사용하는 페이지의 렌더링 수행이 서버에서 시작한다.
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화(serialize)한다. 그리고 이 결과물(와이어 포멧)을 스트리밍해 클라이언트에 제공한다.
3. 브라우저가 서버로부터 받은 결과물을 파싱하여 트리를 재구성해 컴포넌트를 만들어 나간다. 최종적으로 리액트 트리를 렌더링해 브라우저의 DOM에 커밋한다.

##### 서버 컴포넌트의 장점
1. 서버에서 클라이언트로 정보를 보낼 때 스트리밍 형태로 보냄으로써 클라이언트가 줄 단위로 JSON을 읽고 컴포넌트를 렌더링할 수 있어 브라우저에서는 되도록 빨리 사용자에게 결과물을 보여줄 수 있다는 장점이 있다.
2. 각 컴포넌트별로 번들링이 별개로 돼 있어 필요에 따라 컴포넌트를 지연해서 받거나 따로 받는 등의 작업이 가능해졌다.
3. 서버 사이드 렌더링과는 다르게 결과물이 HTML이 아닌 단순한 리액트 컴포넌트 구조를 JSON 형태로 받아서 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있도록 해준다.

### 3. Next.js 13에서의 리액트 서버 컴포넌트
- Next.js도 13버전부터 서버 컴포넌트를 도입했고, 이 서버 컴포넌트가 /app 디렉터리에 구현 돼 있다.
- 서버 컴포넌트는 클라이언트 컴포넌트를 불러올 수 없으며, 클라이언트 컴포넌트는 서버 컴포넌트를 children props로 받는 것만 가능하다.
- 루트 컴포넌트 즉, page.js와 layout.js는 반드시 서버 컴포넌트여야 한다.

### Next.js에서 서버 컴포넌트를 도입하면서 달라진 부분
#### 3-1. 새로운 fetch 도입과 /app 디렉터리 내부에 getServerSideProps, getStaticProps, getInitialProps 메서드가 삭제되었다.
- 리액트 팀은 fetch API를 확장해, 같은 서버 컴포넌트 트리 내에 동일한 요청이 있다면 재요청이 발생하지 않도록 요청 중복을 방지했다.
#### 3-2. 정적 렌더링과 동적 렌더링
- Next.js 13에서는 이제 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재사용할 수 있게끔 해뒀고, 동적인 라우팅에 대해서는 서버에 매번 요청이 올 때마다 컴포넌트를 렌더링하도록 변경했다.
- 함수 내부에서 `next/headers`나 `next/cookie` 같은 헤더 정보와 쿠키 정보를 불러오는 함수를 사용하게 된다면 동적인 연산을 바탕으로 결과를 반환하는 것으로 인식해 정적 렌더링 대상에서 제외된다.
- 동적인 주소이지만 특정 주소에 대해서 캐싱하고 싶은 경우, `generateStaticParams` 함수를 사용하여 기존 `getStaticProps`의 작동 방식 처럼 사용할 수 있다.

##### fetch option
- `{cache: 'force-cache'}`: 기본값으로 getStaticProps와 유사하게 불러온 데이터를 캐싱해 해당 데이터로만 관리한다.
- `{cache: 'no-store'}`: 매번 요청이 올 때마다 새로운 데이터를 불러온다.
- `{revalidate: 10}`: getStaticProps에 revalidate를 추가한 것과 동일하며, 정해진 유효시간 동안에는 캐싱하고, 이 유효시간이 지나면 캐시를 파기한다.

#### 3-3. 캐시와 mutating, 그리고 revalidating
- 페이지 레벨로 데이터의 유효한 시간을 정해 둘 수 있다.
```tsx
// app/page.tsx
export const revalidate = 60;
```
- 캐시를 무효화 시키고 싶을 때 `router.refresh()`를 호출하면 된다. 
  - 브라우저 새로고침 등 브라우저의 히스토리에 영향을 미치지 않고, 오로지 서버에서 루트부터 데이터를 전체적으로 가져와서 갱신하게 된다.
  - 이 작업은 브라우저나 리액트의 state에는 영향을 미치지 않는다.

#### 3-4. HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내는 스트리밍 도입
### 4. 터보팩 등장
- Next.js 13에서는 러스트 기반으로 작성되어 웹팩보다 빠른 성능을 보장하는 터보팩이 등장했다.

### 5. 서버 액션
- API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능이다.


## Next.js 13 미만 버전에 대한 마이그레이션 가이드
https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration
### Next.js 13 App Router 마이그레이션 요약

#### 📌 **업그레이드 개요**
- Next.js 13에서는 **App Router (`app` 디렉토리)** 도입.
- 기존 `pages` 디렉토리에서 **점진적 마이그레이션** 가능.
- **최소 Node.js 버전**: v16.8 이상.
- **업데이트 필수 패키지**:
  - Next.js, React, React DOM 최신 버전.
  - ESLint 사용 시 `eslint-config-next` 최신 버전으로 업그레이드.

#### 🚀 **새로운 기능 및 변경 사항**
- `<Image>` 컴포넌트 개선:
  - 클라이언트 측 JavaScript 감소.
  - 스타일링 및 접근성 향상.
- `<Link>` 컴포넌트 개선:
  - 더 이상 `<a>` 태그를 자식 요소로 필요하지 않음.
  - 자체적으로 `<a>` 렌더링 가능.
- `<Script>` 컴포넌트 변경:
  - strategy 속성이 `beforeInteractive` 인 `<Script>`는 **루트 레이아웃 파일**로 이동 필요.
  - `beforeInteractive`: 
    - 페이지가 상호작용되기 전에 로드 된다.
    - 서버에서 초기 Html을 보낼 때 주입되고, 번들이 된 자바스크립트가 실행하기 전에 먼저 실행된다.
    - 보통 페이지가 상호작용 되기 전에 반드시 스크립트가 필요로 할 때 생성된다.
    - Next.js 13 이전 버전에서 일반적으로는 오로지 _document 파일 안에만 실행할 수 있도록 디자인 되었다. 이유는 _doucment 파일을 벗어나는 순간 순서를 보장할 수 없기 때문.
- **폰트 최적화** (`next/font` 도입):
  - 성능 개선 및 개인정보 보호 강화.

#### 🔄 **마이그레이션 가이드**
- `pages` → `app` 디렉토리로 **페이지별 점진적 전환 가능**.
- `app` 디렉토리는 **중첩된 라우트와 레이아웃 지원**.
- 특수한 파일 규칙을 통해 **각 경로의 UI를 정의** 가능.
- **루트 레이아웃 (`layout.tsx` or `layout.js`) 필수**:
  - `<html>` 및 `<body>` 태그를 정의해야 함.
  - 기존 `pages/_app.js` 및 `pages/_document.js`를 대체.
- `pages` 디렉토리 유지하면서 마이그레이션 가능하지만:
  - 모든 경로 이동 후 `_app` 및 `_document` 삭제 가능.

#### 🎯 **기대 효과**
- 새로운 구조를 활용하여 **성능 및 개발자 경험 향상**.
- 더 나은 **라우팅 관리 및 코드 구조 최적화 가능**.

✅ **결론**: Next.js 13의 App Router로 전환하면 **더 나은 성능과 개발 생산성**을 확보할 수 있음. 🚀

